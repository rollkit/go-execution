// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: execution/execution.proto

package execution

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type InitChainRequest struct {
	GenesisTime   int64  `protobuf:"varint,1,opt,name=genesis_time,json=genesisTime,proto3" json:"genesis_time,omitempty"`
	InitialHeight uint64 `protobuf:"varint,2,opt,name=initial_height,json=initialHeight,proto3" json:"initial_height,omitempty"`
	ChainId       string `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *InitChainRequest) Reset()         { *m = InitChainRequest{} }
func (m *InitChainRequest) String() string { return proto.CompactTextString(m) }
func (*InitChainRequest) ProtoMessage()    {}
func (*InitChainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a4329d6cc9a89db, []int{0}
}
func (m *InitChainRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitChainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitChainRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitChainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitChainRequest.Merge(m, src)
}
func (m *InitChainRequest) XXX_Size() int {
	return m.Size()
}
func (m *InitChainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InitChainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InitChainRequest proto.InternalMessageInfo

func (m *InitChainRequest) GetGenesisTime() int64 {
	if m != nil {
		return m.GenesisTime
	}
	return 0
}

func (m *InitChainRequest) GetInitialHeight() uint64 {
	if m != nil {
		return m.InitialHeight
	}
	return 0
}

func (m *InitChainRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type InitChainResponse struct {
	StateRoot []byte `protobuf:"bytes,1,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	MaxBytes  uint64 `protobuf:"varint,2,opt,name=max_bytes,json=maxBytes,proto3" json:"max_bytes,omitempty"`
}

func (m *InitChainResponse) Reset()         { *m = InitChainResponse{} }
func (m *InitChainResponse) String() string { return proto.CompactTextString(m) }
func (*InitChainResponse) ProtoMessage()    {}
func (*InitChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a4329d6cc9a89db, []int{1}
}
func (m *InitChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitChainResponse.Merge(m, src)
}
func (m *InitChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *InitChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InitChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InitChainResponse proto.InternalMessageInfo

func (m *InitChainResponse) GetStateRoot() []byte {
	if m != nil {
		return m.StateRoot
	}
	return nil
}

func (m *InitChainResponse) GetMaxBytes() uint64 {
	if m != nil {
		return m.MaxBytes
	}
	return 0
}

type GetTxsRequest struct {
}

func (m *GetTxsRequest) Reset()         { *m = GetTxsRequest{} }
func (m *GetTxsRequest) String() string { return proto.CompactTextString(m) }
func (*GetTxsRequest) ProtoMessage()    {}
func (*GetTxsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a4329d6cc9a89db, []int{2}
}
func (m *GetTxsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxsRequest.Merge(m, src)
}
func (m *GetTxsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTxsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxsRequest proto.InternalMessageInfo

type GetTxsResponse struct {
	Txs [][]byte `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
}

func (m *GetTxsResponse) Reset()         { *m = GetTxsResponse{} }
func (m *GetTxsResponse) String() string { return proto.CompactTextString(m) }
func (*GetTxsResponse) ProtoMessage()    {}
func (*GetTxsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a4329d6cc9a89db, []int{3}
}
func (m *GetTxsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTxsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTxsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTxsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTxsResponse.Merge(m, src)
}
func (m *GetTxsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTxsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTxsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTxsResponse proto.InternalMessageInfo

func (m *GetTxsResponse) GetTxs() [][]byte {
	if m != nil {
		return m.Txs
	}
	return nil
}

type ExecuteTxsRequest struct {
	Txs           [][]byte `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
	BlockHeight   uint64   `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	Timestamp     int64    `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	PrevStateRoot []byte   `protobuf:"bytes,4,opt,name=prev_state_root,json=prevStateRoot,proto3" json:"prev_state_root,omitempty"`
}

func (m *ExecuteTxsRequest) Reset()         { *m = ExecuteTxsRequest{} }
func (m *ExecuteTxsRequest) String() string { return proto.CompactTextString(m) }
func (*ExecuteTxsRequest) ProtoMessage()    {}
func (*ExecuteTxsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a4329d6cc9a89db, []int{4}
}
func (m *ExecuteTxsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteTxsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteTxsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteTxsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteTxsRequest.Merge(m, src)
}
func (m *ExecuteTxsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteTxsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteTxsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteTxsRequest proto.InternalMessageInfo

func (m *ExecuteTxsRequest) GetTxs() [][]byte {
	if m != nil {
		return m.Txs
	}
	return nil
}

func (m *ExecuteTxsRequest) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ExecuteTxsRequest) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ExecuteTxsRequest) GetPrevStateRoot() []byte {
	if m != nil {
		return m.PrevStateRoot
	}
	return nil
}

type ExecuteTxsResponse struct {
	UpdatedStateRoot []byte `protobuf:"bytes,1,opt,name=updated_state_root,json=updatedStateRoot,proto3" json:"updated_state_root,omitempty"`
	MaxBytes         uint64 `protobuf:"varint,2,opt,name=max_bytes,json=maxBytes,proto3" json:"max_bytes,omitempty"`
}

func (m *ExecuteTxsResponse) Reset()         { *m = ExecuteTxsResponse{} }
func (m *ExecuteTxsResponse) String() string { return proto.CompactTextString(m) }
func (*ExecuteTxsResponse) ProtoMessage()    {}
func (*ExecuteTxsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a4329d6cc9a89db, []int{5}
}
func (m *ExecuteTxsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteTxsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteTxsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteTxsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteTxsResponse.Merge(m, src)
}
func (m *ExecuteTxsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteTxsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteTxsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteTxsResponse proto.InternalMessageInfo

func (m *ExecuteTxsResponse) GetUpdatedStateRoot() []byte {
	if m != nil {
		return m.UpdatedStateRoot
	}
	return nil
}

func (m *ExecuteTxsResponse) GetMaxBytes() uint64 {
	if m != nil {
		return m.MaxBytes
	}
	return 0
}

type SetFinalRequest struct {
	BlockHeight uint64 `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
}

func (m *SetFinalRequest) Reset()         { *m = SetFinalRequest{} }
func (m *SetFinalRequest) String() string { return proto.CompactTextString(m) }
func (*SetFinalRequest) ProtoMessage()    {}
func (*SetFinalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a4329d6cc9a89db, []int{6}
}
func (m *SetFinalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetFinalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetFinalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetFinalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetFinalRequest.Merge(m, src)
}
func (m *SetFinalRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetFinalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetFinalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetFinalRequest proto.InternalMessageInfo

func (m *SetFinalRequest) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

type SetFinalResponse struct {
}

func (m *SetFinalResponse) Reset()         { *m = SetFinalResponse{} }
func (m *SetFinalResponse) String() string { return proto.CompactTextString(m) }
func (*SetFinalResponse) ProtoMessage()    {}
func (*SetFinalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a4329d6cc9a89db, []int{7}
}
func (m *SetFinalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetFinalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetFinalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetFinalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetFinalResponse.Merge(m, src)
}
func (m *SetFinalResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetFinalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetFinalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetFinalResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*InitChainRequest)(nil), "execution.InitChainRequest")
	proto.RegisterType((*InitChainResponse)(nil), "execution.InitChainResponse")
	proto.RegisterType((*GetTxsRequest)(nil), "execution.GetTxsRequest")
	proto.RegisterType((*GetTxsResponse)(nil), "execution.GetTxsResponse")
	proto.RegisterType((*ExecuteTxsRequest)(nil), "execution.ExecuteTxsRequest")
	proto.RegisterType((*ExecuteTxsResponse)(nil), "execution.ExecuteTxsResponse")
	proto.RegisterType((*SetFinalRequest)(nil), "execution.SetFinalRequest")
	proto.RegisterType((*SetFinalResponse)(nil), "execution.SetFinalResponse")
}

func init() { proto.RegisterFile("execution/execution.proto", fileDescriptor_0a4329d6cc9a89db) }

var fileDescriptor_0a4329d6cc9a89db = []byte{
	// 493 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xce, 0x36, 0x55, 0xa9, 0xa7, 0x49, 0x93, 0xee, 0x29, 0x3f, 0xad, 0x15, 0x2c, 0x15, 0xe5,
	0x80, 0x12, 0x09, 0xb8, 0x57, 0x2a, 0x0a, 0xb4, 0xe2, 0x80, 0xe4, 0xf4, 0xc4, 0xc5, 0xb2, 0x9d,
	0x51, 0xb2, 0xaa, 0xed, 0x35, 0xde, 0x49, 0x71, 0x5f, 0x02, 0xf1, 0x2a, 0xbc, 0x05, 0xc7, 0x1e,
	0x39, 0xa2, 0xe4, 0x45, 0x90, 0x1d, 0xff, 0xa5, 0x09, 0x12, 0xb7, 0xdd, 0x6f, 0x66, 0xbf, 0x99,
	0xef, 0x9b, 0x59, 0xe8, 0x62, 0x8c, 0xee, 0x92, 0x84, 0x0c, 0xc6, 0xc5, 0x69, 0x14, 0x46, 0x92,
	0x24, 0xd7, 0x0a, 0xc0, 0xf8, 0x06, 0xed, 0xdb, 0x40, 0xd0, 0xfb, 0x85, 0x2d, 0x02, 0x13, 0xbf,
	0x2e, 0x51, 0x11, 0x7f, 0x09, 0x8d, 0x39, 0x06, 0xa8, 0x84, 0xb2, 0x48, 0xf8, 0xd8, 0x61, 0x03,
	0x36, 0xac, 0x9b, 0x27, 0x19, 0x76, 0x27, 0x7c, 0xe4, 0x97, 0x70, 0x2a, 0x02, 0x41, 0xc2, 0xf6,
	0xac, 0x05, 0x8a, 0xf9, 0x82, 0x3a, 0x07, 0x03, 0x36, 0x3c, 0x34, 0x9b, 0x19, 0x7a, 0x93, 0x82,
	0xbc, 0x0b, 0xc7, 0x6e, 0xc2, 0x6c, 0x89, 0x59, 0xa7, 0x3e, 0x60, 0x43, 0xcd, 0x7c, 0x91, 0xde,
	0x6f, 0x67, 0xc6, 0x67, 0x38, 0xab, 0x14, 0x56, 0xa1, 0x0c, 0x14, 0xf2, 0x0b, 0x00, 0x45, 0x36,
	0xa1, 0x15, 0x49, 0x49, 0x69, 0xdd, 0x86, 0xa9, 0xa5, 0x88, 0x29, 0x25, 0xf1, 0x3e, 0x68, 0xbe,
	0x1d, 0x5b, 0xce, 0x23, 0xa1, 0xca, 0x0a, 0x1e, 0xfb, 0x76, 0x7c, 0x9d, 0xdc, 0x8d, 0x16, 0x34,
	0x3f, 0x22, 0xdd, 0xc5, 0x2a, 0x93, 0x61, 0x18, 0x70, 0x9a, 0x03, 0x19, 0x7d, 0x1b, 0xea, 0x14,
	0xab, 0x0e, 0x1b, 0xd4, 0x87, 0x0d, 0x33, 0x39, 0x1a, 0xdf, 0x19, 0x9c, 0x4d, 0x52, 0x33, 0xb0,
	0x7c, 0xb9, 0x9b, 0x97, 0x58, 0xe2, 0x78, 0xd2, 0xbd, 0xdf, 0x56, 0x7b, 0x92, 0x62, 0x99, 0xd6,
	0x73, 0xd0, 0x12, 0xb7, 0x14, 0xd9, 0x7e, 0x98, 0x8a, 0xad, 0x9b, 0x25, 0xc0, 0x5f, 0x41, 0x2b,
	0x8c, 0xf0, 0xc1, 0xaa, 0xc8, 0x3b, 0x4c, 0xe5, 0x35, 0x13, 0x78, 0x9a, 0x4b, 0x34, 0x2c, 0xe0,
	0xd5, 0x7e, 0xb2, 0xc6, 0x5f, 0x03, 0x5f, 0x86, 0x33, 0x9b, 0x70, 0x66, 0xed, 0xf8, 0xd3, 0xce,
	0x22, 0xd3, 0xff, 0xb3, 0xe9, 0x1d, 0xb4, 0xa6, 0x48, 0x1f, 0x44, 0x60, 0x7b, 0x95, 0x79, 0x6f,
	0x89, 0x63, 0x3b, 0xe2, 0x0c, 0x0e, 0xed, 0xf2, 0xd5, 0xa6, 0xa9, 0x37, 0x3f, 0x0f, 0xa0, 0x3d,
	0xc9, 0x17, 0x69, 0x8a, 0xd1, 0x83, 0x70, 0x91, 0xdf, 0x80, 0x56, 0x8c, 0x95, 0xf7, 0x47, 0xe5,
	0xe6, 0x3d, 0xdf, 0xb2, 0xde, 0xf9, 0xfe, 0xe0, 0x86, 0xdc, 0xa8, 0xf1, 0x2b, 0x38, 0xda, 0x8c,
	0x8f, 0x77, 0x2a, 0x99, 0x5b, 0x23, 0xee, 0x75, 0xf7, 0x44, 0x0a, 0x82, 0x4f, 0x00, 0xa5, 0x95,
	0xbc, 0x5a, 0x6e, 0x67, 0xe2, 0xbd, 0x8b, 0x7f, 0x44, 0x0b, 0xb2, 0x09, 0x1c, 0xe7, 0x06, 0xf0,
	0x5e, 0x25, 0xf9, 0x99, 0x97, 0xbd, 0xfe, 0xde, 0x58, 0x4e, 0x73, 0x7d, 0xf5, 0x6b, 0xa5, 0xb3,
	0xa7, 0x95, 0xce, 0xfe, 0xac, 0x74, 0xf6, 0x63, 0xad, 0xd7, 0x9e, 0xd6, 0x7a, 0xed, 0xf7, 0x5a,
	0xaf, 0x7d, 0xb9, 0x9c, 0x0b, 0x5a, 0x2c, 0x9d, 0x91, 0x2b, 0xfd, 0x71, 0x24, 0x3d, 0xef, 0x5e,
	0xd0, 0x98, 0x1e, 0x43, 0x54, 0xe3, 0xd0, 0x29, 0x3f, 0xb0, 0x73, 0x94, 0xfe, 0xe0, 0xb7, 0x7f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x11, 0x22, 0x22, 0x7d, 0xde, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ExecutionServiceClient is the client API for ExecutionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExecutionServiceClient interface {
	InitChain(ctx context.Context, in *InitChainRequest, opts ...grpc.CallOption) (*InitChainResponse, error)
	GetTxs(ctx context.Context, in *GetTxsRequest, opts ...grpc.CallOption) (*GetTxsResponse, error)
	ExecuteTxs(ctx context.Context, in *ExecuteTxsRequest, opts ...grpc.CallOption) (*ExecuteTxsResponse, error)
	SetFinal(ctx context.Context, in *SetFinalRequest, opts ...grpc.CallOption) (*SetFinalResponse, error)
}

type executionServiceClient struct {
	cc grpc1.ClientConn
}

func NewExecutionServiceClient(cc grpc1.ClientConn) ExecutionServiceClient {
	return &executionServiceClient{cc}
}

func (c *executionServiceClient) InitChain(ctx context.Context, in *InitChainRequest, opts ...grpc.CallOption) (*InitChainResponse, error) {
	out := new(InitChainResponse)
	err := c.cc.Invoke(ctx, "/execution.ExecutionService/InitChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionServiceClient) GetTxs(ctx context.Context, in *GetTxsRequest, opts ...grpc.CallOption) (*GetTxsResponse, error) {
	out := new(GetTxsResponse)
	err := c.cc.Invoke(ctx, "/execution.ExecutionService/GetTxs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionServiceClient) ExecuteTxs(ctx context.Context, in *ExecuteTxsRequest, opts ...grpc.CallOption) (*ExecuteTxsResponse, error) {
	out := new(ExecuteTxsResponse)
	err := c.cc.Invoke(ctx, "/execution.ExecutionService/ExecuteTxs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *executionServiceClient) SetFinal(ctx context.Context, in *SetFinalRequest, opts ...grpc.CallOption) (*SetFinalResponse, error) {
	out := new(SetFinalResponse)
	err := c.cc.Invoke(ctx, "/execution.ExecutionService/SetFinal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExecutionServiceServer is the server API for ExecutionService service.
type ExecutionServiceServer interface {
	InitChain(context.Context, *InitChainRequest) (*InitChainResponse, error)
	GetTxs(context.Context, *GetTxsRequest) (*GetTxsResponse, error)
	ExecuteTxs(context.Context, *ExecuteTxsRequest) (*ExecuteTxsResponse, error)
	SetFinal(context.Context, *SetFinalRequest) (*SetFinalResponse, error)
}

// UnimplementedExecutionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedExecutionServiceServer struct {
}

func (*UnimplementedExecutionServiceServer) InitChain(ctx context.Context, req *InitChainRequest) (*InitChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitChain not implemented")
}
func (*UnimplementedExecutionServiceServer) GetTxs(ctx context.Context, req *GetTxsRequest) (*GetTxsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxs not implemented")
}
func (*UnimplementedExecutionServiceServer) ExecuteTxs(ctx context.Context, req *ExecuteTxsRequest) (*ExecuteTxsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteTxs not implemented")
}
func (*UnimplementedExecutionServiceServer) SetFinal(ctx context.Context, req *SetFinalRequest) (*SetFinalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFinal not implemented")
}

func RegisterExecutionServiceServer(s grpc1.Server, srv ExecutionServiceServer) {
	s.RegisterService(&_ExecutionService_serviceDesc, srv)
}

func _ExecutionService_InitChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServiceServer).InitChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/execution.ExecutionService/InitChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServiceServer).InitChain(ctx, req.(*InitChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecutionService_GetTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTxsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServiceServer).GetTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/execution.ExecutionService/GetTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServiceServer).GetTxs(ctx, req.(*GetTxsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecutionService_ExecuteTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteTxsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServiceServer).ExecuteTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/execution.ExecutionService/ExecuteTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServiceServer).ExecuteTxs(ctx, req.(*ExecuteTxsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExecutionService_SetFinal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFinalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutionServiceServer).SetFinal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/execution.ExecutionService/SetFinal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutionServiceServer).SetFinal(ctx, req.(*SetFinalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExecutionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "execution.ExecutionService",
	HandlerType: (*ExecutionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitChain",
			Handler:    _ExecutionService_InitChain_Handler,
		},
		{
			MethodName: "GetTxs",
			Handler:    _ExecutionService_GetTxs_Handler,
		},
		{
			MethodName: "ExecuteTxs",
			Handler:    _ExecutionService_ExecuteTxs_Handler,
		},
		{
			MethodName: "SetFinal",
			Handler:    _ExecutionService_SetFinal_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "execution/execution.proto",
}

func (m *InitChainRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitChainRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitChainRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintExecution(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.InitialHeight != 0 {
		i = encodeVarintExecution(dAtA, i, uint64(m.InitialHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.GenesisTime != 0 {
		i = encodeVarintExecution(dAtA, i, uint64(m.GenesisTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InitChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitChainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitChainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxBytes != 0 {
		i = encodeVarintExecution(dAtA, i, uint64(m.MaxBytes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.StateRoot) > 0 {
		i -= len(m.StateRoot)
		copy(dAtA[i:], m.StateRoot)
		i = encodeVarintExecution(dAtA, i, uint64(len(m.StateRoot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTxsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetTxsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTxsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTxsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Txs) > 0 {
		for iNdEx := len(m.Txs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Txs[iNdEx])
			copy(dAtA[i:], m.Txs[iNdEx])
			i = encodeVarintExecution(dAtA, i, uint64(len(m.Txs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteTxsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteTxsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteTxsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrevStateRoot) > 0 {
		i -= len(m.PrevStateRoot)
		copy(dAtA[i:], m.PrevStateRoot)
		i = encodeVarintExecution(dAtA, i, uint64(len(m.PrevStateRoot)))
		i--
		dAtA[i] = 0x22
	}
	if m.Timestamp != 0 {
		i = encodeVarintExecution(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockHeight != 0 {
		i = encodeVarintExecution(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Txs) > 0 {
		for iNdEx := len(m.Txs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Txs[iNdEx])
			copy(dAtA[i:], m.Txs[iNdEx])
			i = encodeVarintExecution(dAtA, i, uint64(len(m.Txs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteTxsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteTxsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteTxsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxBytes != 0 {
		i = encodeVarintExecution(dAtA, i, uint64(m.MaxBytes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UpdatedStateRoot) > 0 {
		i -= len(m.UpdatedStateRoot)
		copy(dAtA[i:], m.UpdatedStateRoot)
		i = encodeVarintExecution(dAtA, i, uint64(len(m.UpdatedStateRoot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetFinalRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetFinalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetFinalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintExecution(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetFinalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetFinalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetFinalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintExecution(dAtA []byte, offset int, v uint64) int {
	offset -= sovExecution(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InitChainRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GenesisTime != 0 {
		n += 1 + sovExecution(uint64(m.GenesisTime))
	}
	if m.InitialHeight != 0 {
		n += 1 + sovExecution(uint64(m.InitialHeight))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovExecution(uint64(l))
	}
	return n
}

func (m *InitChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateRoot)
	if l > 0 {
		n += 1 + l + sovExecution(uint64(l))
	}
	if m.MaxBytes != 0 {
		n += 1 + sovExecution(uint64(m.MaxBytes))
	}
	return n
}

func (m *GetTxsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetTxsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Txs) > 0 {
		for _, b := range m.Txs {
			l = len(b)
			n += 1 + l + sovExecution(uint64(l))
		}
	}
	return n
}

func (m *ExecuteTxsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Txs) > 0 {
		for _, b := range m.Txs {
			l = len(b)
			n += 1 + l + sovExecution(uint64(l))
		}
	}
	if m.BlockHeight != 0 {
		n += 1 + sovExecution(uint64(m.BlockHeight))
	}
	if m.Timestamp != 0 {
		n += 1 + sovExecution(uint64(m.Timestamp))
	}
	l = len(m.PrevStateRoot)
	if l > 0 {
		n += 1 + l + sovExecution(uint64(l))
	}
	return n
}

func (m *ExecuteTxsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UpdatedStateRoot)
	if l > 0 {
		n += 1 + l + sovExecution(uint64(l))
	}
	if m.MaxBytes != 0 {
		n += 1 + sovExecution(uint64(m.MaxBytes))
	}
	return n
}

func (m *SetFinalRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovExecution(uint64(m.BlockHeight))
	}
	return n
}

func (m *SetFinalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovExecution(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExecution(x uint64) (n int) {
	return sovExecution(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InitChainRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitChainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitChainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisTime", wireType)
			}
			m.GenesisTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenesisTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialHeight", wireType)
			}
			m.InitialHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecution
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecution
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateRoot = append(m.StateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.StateRoot == nil {
				m.StateRoot = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBytes", wireType)
			}
			m.MaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExecution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTxsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTxsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTxsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecution
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, make([]byte, postIndex-iNdEx))
			copy(m.Txs[len(m.Txs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteTxsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteTxsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteTxsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecution
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, make([]byte, postIndex-iNdEx))
			copy(m.Txs[len(m.Txs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevStateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecution
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevStateRoot = append(m.PrevStateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.PrevStateRoot == nil {
				m.PrevStateRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteTxsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteTxsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteTxsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedStateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExecution
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExecution
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedStateRoot = append(m.UpdatedStateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.UpdatedStateRoot == nil {
				m.UpdatedStateRoot = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBytes", wireType)
			}
			m.MaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetFinalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetFinalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetFinalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetFinalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecution
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetFinalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetFinalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExecution(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecution
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExecution(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExecution
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecution
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExecution
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupExecution
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthExecution
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthExecution        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExecution          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupExecution = fmt.Errorf("proto: unexpected end of group")
)
